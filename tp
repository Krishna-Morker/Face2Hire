'use client';

import React, { useEffect, useRef, useState } from 'react';

export default function VideoSession() {
  const [isSessionStarted, setIsSessionStarted] = useState(false);
  const [question, setQuestion] = useState('');
  const [feedback, setFeedback] = useState('');
  const [intervalId, setIntervalId] = useState(null);
  const [isEvaluating, setIsEvaluating] = useState(false);
  const [error, setError] = useState('');

  const userVideoRef = useRef(null);
  const aiVideoRef = useRef(null);
  const recognitionRef = useRef(null);
  const lastQuestionRef = useRef('');

  const close = () => {
    setIsSessionStarted(false);
    clearInterval(intervalId);
    setIntervalId(null);
    setQuestion('');
    setFeedback('');
    setError('');
    if (recognitionRef.current) recognitionRef.current.stop();
    const stream = userVideoRef.current?.srcObject;
    if (stream) {
      stream.getTracks().forEach(track => track.stop());
    }
  };

  const askQuestion = async () => {
    try {
      const res = await fetch('/api/ask-question', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ topic: 'JavaScript' }),
      });
      const data = await res.json();
      setQuestion(data.question);
      lastQuestionRef.current = data.question;
      speakQuestion(data.question);
    } catch (err) {
      console.error('Error asking question:', err);
    }
  };

  const speakQuestion = (text) => {
    const utterance = new SpeechSynthesisUtterance(text);
    speechSynthesis.speak(utterance);
    utterance.onend = () => startRecordingAnswer();
  };

  const startRecordingAnswer = () => {
    if (!('webkitSpeechRecognition' in window)) {
      setError('Speech recognition not supported in this browser.');
      return;
    }

    const SpeechRecognition = window.webkitSpeechRecognition;
    const recognition = new SpeechRecognition();
    recognition.lang = 'en-US';
    recognition.interimResults = false;
    recognition.maxAlternatives = 1;

    recognition.onresult = async (event) => {
      const answer = event.results[0][0].transcript;
      console.log('User Answer:', answer);
      evaluateAnswer(answer);
    };

    recognition.onerror = (event) => {
      console.error('Speech recognition error:', event);
      setError('Speech recognition failed. Try again.');
    };

    recognitionRef.current = recognition;
    recognition.start();
  };

  const evaluateAnswer = async (answer) => {
    setIsEvaluating(true);
    try {
      const res = await fetch('/api/evaluate-answer', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ question: lastQuestionRef.current, answer }),
      });
      const data = await res.json();
      setFeedback(data.feedback);
    } catch (err) {
      console.error('Error evaluating answer:', err);
      setError('Could not evaluate answer. Try again later.');
    }
    setIsEvaluating(false);
  };

  const startSession = async () => {
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const hasVideo = devices.some(device => device.kind === 'videoinput');
      const hasAudio = devices.some(device => device.kind === 'audioinput');

      if (!hasVideo || !hasAudio) {
        setError('Camera or microphone not found.');
        return;
      }

      const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      if (userVideoRef.current) {
        userVideoRef.current.srcObject = stream;
      }
      if (aiVideoRef.current) {
        aiVideoRef.current.play();
      }

      setIsSessionStarted(true);
      await askQuestion();
      const id = setInterval(askQuestion, 30000);
      setIntervalId(id);
    } catch (err) {
      console.error('Error accessing webcam or microphone:', err);
      setError('Could not access camera/mic. Please check permissions.');
    }
  };

  return (
    <div className="min-h-screen bg-gray-900 flex flex-col items-center justify-center p-6 text-white">
      {!isSessionStarted && (
        <>
          {error && <p className="text-red-500 mb-4">{error}</p>}
          <button
            onClick={startSession}
            className="mb-6 bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition"
          >
            Start Session
          </button>
        </>
      )}

      {isSessionStarted && (
        <>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6 w-full">
            <div className="bg-gray-700 shadow rounded p-4 text-center">
              <h2 className="text-lg font-semibold mb-2">You</h2>
              <video ref={userVideoRef} autoPlay playsInline muted className="w-full rounded" />
            </div>

            <div className="bg-gray-700 shadow rounded p-4 text-center">
              <h2 className="text-lg font-semibold mb-2">AI Interviewer</h2>
              <video
                ref={aiVideoRef}
                controls={false}
                className="w-full rounded"
                src="/WIN_20240928_11_52_57_Pro.mp4"
              />
            </div>
          </div>

          <div className="mt-6 w-full max-w-2xl">
            <div className="bg-gray-800 rounded p-4 mb-4">
              <h3 className="font-semibold text-lg mb-2">Current Question:</h3>
              <p>{question || 'Waiting for question...'}</p>
            </div>

            {isEvaluating && <p className="text-yellow-400">Evaluating your answer...</p>}

            {feedback && (
              <div className="bg-gray-800 rounded p-4">
                <h3 className="font-semibold text-lg mb-2">AI Feedback:</h3>
                <p>{feedback}</p>
              </div>
            )}

            {error && <p className="text-red-500 mt-4">{error}</p>}
          </div>

          <button className="mt-6 bg-red-600 text-white px-4 py-2 rounded" onClick={close}>
            End Session
          </button>
        </>
      )}
    </div>
  );
}
